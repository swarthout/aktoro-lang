
Basic Types:
int
list
float
string
tag
record
map
function
bool
variant
atom


let g = [3, 4, 5]

let a = 4

a = 4

let b = "hello"

let add_them = fn (a int, b int) int => {
    a + b
}

let also_adds = fn (a int, b int) => a + b

let add_generic = fn (a 't, b 't) 't => a + b

let c = add_generic (3, 4)

let list_creator = fn (typ 't) => {
    let h = heap.init(typ, [])
}

let ignore_second = fn (b int, _) => b + 2

type result 't = :ok 't | :error string

let private_func = fn (b int, {a, c} user) => {
    g = match return_value(a) {
        :ok v => v,
        :error "specific message" => "hello",
        :error message => message
    }
}

private_func (5, user{a="scott", b="swarthout"})

enum.each(0..10, fn (i) => {
})


let mut a = 4

a = 5

let changes_val = fn (mut b) => {
    b = 3
}

changes_val(a)

# a = 4

type map 'k 'v = {

}

let v = %{
    3 => "three",
    4 => "four",
    5 => "five"
}

w = %{v | 6 => "six", 5 => "cinco"}

l list int = [0..17]

l = [0..23]

v = l[4..8]

x = l[7..1]

d = l[2..]

e = l[..4]

type user = {a string, b string}

let u = {a="hello", b="world"}

let r = {u | b="again"}

type heap 't = {

}

let a = with {
    b <- returns_result()
    c <- get_other_thing(b)
    d <- another_op()
} yield perform_thing(c, d)

user_id = "Scott",
    age = 21,
    car = {
        name = "Mustang",
        miles = 12345
        }
import fmt from "std/fmt"
import user, comment from "github.com/scott/blog"

import http from "std/net/http"

let post_handler = fn (r http.request) => {
    let {id, username} = http.get_vars(r)
}

use http.{request, get, post}
let req_handler = fn (r request) => {
     let routes = {
        :get "/hello" => fn (r request) => {
            "Yo Dawg"
        },
        :post "/hello/{id}" => fn (r request) => {
            let {id} = http.get_vars(r)
            let response = dict int string {}
            json.dump(response)
        },
        :post "/hello/{id int}/{username option string}" => post_handler
        }
    }
}

let server = http.server{port=3000, router=req_handler}

http.listen (server)

type comment = {user_id int, comment_id int, text string}

let s = r.b

v[3]

let a = [3, 4, 5]

a = b <> "world!"

module math = {
    let sum = fn (a int, b int) => do_sum_ (a, b)
    
    let do_sum_ = fn (a int, b int) int => a + b

    let is_zero = fn (a int) bool => {
        match a {
            0 => true,
            _ => false
        }
    }

    let positive = fn (x int) bool => {
        match {
            x < 0 => false,
            x >= 0 => true
        }
    }
}

let anonymous_func = fn (a, b) => a + b

module stack = {
    type state 't = {
        data list 't,
        buffer_size int
    }
    let init = fn (init_list list 't, buffer_size int) state 't => {
        {data = init_list, buffer_size}
    }

    let push = fn (s state 't, e 't) state 't => {
        {s | data=[e | data]}
    }
    let pop = fn (s state 't) state 't => {
        {s | data=data[1..]}
    }
}

s = stack.init ([] :: list int, 5)

let a = 5

s = stack.push (s, 4)

use stack.push

s = push (s, 3)

s = s |> push (6) 

a = stack.pop (s)

# a int = 6

let map_int_string = fn (l list string, f fn (string) string ) list string => {
    list.map(l, f)
}
    
module enum = {
    let map = (l list 'a, f fn ('a) 'b) list 'b => {

    }
    let reduce = (l list 'a, f fn ('a, 'b) 'b) 'b => {

    }
}

l = [4, 5, 6, 7, 8]
use enum.{take, filter, reduce}

num = l

num
|> filter(fn (a) => a % 2 == 0)
|> take(2)
|> reduce(fn (a, b) => a + b)

# num = 10

filtered_list = enum.filter(list, fn (a) => a % 2 == 0)
# filtered_list = [4, 6, 8]

a = 4

if a < 6 {

}
else {

}


type state = { total_count int, reset_count int}

type message = :add int | :reset | :get_count

let counter_reducer = fn (s state, m message, sender option actor) state => {
        match m {
            :add num => ({s | total_count = s.total_count + num}),
            :reset => ({s | total_count = 0, reset_count = s.reset_count + 1}),
            :get_count => {
                actor.reply (sender, s.total_count)
                s
            }
        }
    }
}

type counter_args = {start int}

let init_counter = fn (args counter_args) actor.pid => {
    let init_state = {
        total_count=start,
        reset_count=0
    }
    go (init_state, counter_reducer)
}

let counter = init_counter({start=5})

tell (counter, :add 7)

tell (counter, :reset)

let count = ask (counter, :get_count)

num = match count {
    :ok num => num,
    :error m => m
}

module stack = {

    type state_ 't = {
        data list 't,
        buffer_size int
    }

    type message_ = :push 't | :pop | :get_top

    let reducer_ = fn(s state_ 't, m message_, sender option actor.pid) state_ 't => {
        match m {
            :push e => {
                {s | data = data <> [e]}
             },
            :pop => {
                {s | data=data[..-1]}
            },
            :get_top => {
                actor.reply (sender, s.data[-1])
            }
        }
    }

    let init = fn ('t, buffer_size int ) actor.pid => {
        let init_state = {
            data = list.init('t),
            buffer_size
        }
        actor.go (init_state, reducer_)
    }

    let push = fn (s actor.pid, e 't) => {
        actor.tell (s, :push e)
    }
    let pop = fn (s pid 't) => {
        actor.tell (s, :pop)
    }

    let get_top = fn (s pid 't) 't => {
        actor.ask (s, :get_top)
    } 

}



let s = stack.init (int, 5)

stack.push (s, 4)
stack.push (s, 3)
stack.pop (s)

let top = stack.get_top (s)
