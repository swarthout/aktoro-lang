
Basic Types:
int
list
array
float
string
tag
record
map
function
bool
variant
atom


let g = [|3, 4, 5|]

let a = 4

a = 4

let b = "hello"

let add_them = fn (a int, b int) int => {
    a + b
}

let also_adds = fn (a int, b int) => a + b

let add_generic = fn (a 't, b 't) 't => a + b

let c = add_generic (3, 4)

let list_creator = fn (typ 't) => {
    let h = heap.init(typ, [])
}

let ignore_second = fn (b int, _) => b + 2

type result 't = :ok 't | :error string

let private_func = fn (b int, user{a, c}) => {
    g = match return_value(a) {
        :ok v => v,
        :error "specific message" => "hello",
        :error message => message
    }
}

private_func (5, user{a="scott", b="swarthout"})

enum.each(0..10, fn (i) => {
})


let mut a = 4

a = 5

let changes_val = fn (mut b) => {
    b = 3
}

changes_val(a)

# a = 4

type map 'k 'v = {

}

let v = {
    3 => "three",
    4 => "four",
    5 => "five"
}

w = {v | 6 => "six", 5 => "cinco"}

l list int = [0..17]

l = [0..23]

v = l[4..8]

x = l[7..1]

d = l[2..]

e = l[..4]

type user = {a string, b string}

let u = {a="hello", b="world"}

let r = {u | b="again"}

type heap 't = {

}


import fmt from "std/fmt"
import user, comment from "github.com/scott/blog"

import http from "std/net/http"

let post_handler = fn (r http.request) => {
    let {id, username} = http.get_vars(r)
}

use http.{request, get, post}
let req_handler = fn (r request) => {
     let routes = {
        :get "/hello" => fn (r request) => {
            "Yo Dawg"
        },
        :post "/hello/{id}" => fn (r request) => {
            let {id} = http.get_vars(r)
            let response = map (int, string) {
                id => "Your id is \(id)"
                id + 1 => "The next is \(id + 1)"
            }
            json.dump(response)
        },
        :post "/hello/{id int}/{username option string}" => post_handler
        }
    }
}

let server = http.server{port=3000, router=req_handler}

http.listen (server)

type comment = {user_id int, comment_id int, text string}

let s = r.b

v[3]

let a = [3, 4, 5]

[head | tail] = a

a = b <> "world!"

module math = {
    let sum = fn (a int, b int) => do_sum a, b

    
    let priv do_sum = fn (a int, b int) int => a + b

    let zero? = fn (a int) bool => {
        match a {
            0 => true,
            _ => false
        }
    }

    let positive = fn (x int) => {
        match {
            x < 0 => false,
            x >= 0 => true
        }
    }
}

let anonymous_func = fn (a, b) => a + b

module stack = {
    let init = fn (_ 't, {buffer_size = 5}) stack_state 't => {
        {data = [], buffer_size}
    }
    type stack_state 't = {
        data list 't = [],
        buffer_size = 5
    }
    let push = fn (s stack_state 't, e 't) stack_state 't => {
        {s | data=[e | data]}
    }
    let pop = fn (s stack_state 't) stack_state 't => {
        {s | data=data[1..]}
    }
}

s = stack.init (0, {})

k = stack.init (0, {buffer_size=2})

s = stack.push (s, 4)

use stack.push

s = push (s, 3)

s = s |> push (6) 

a = stack.pop (s)

# a int = 6

let map_int_string = fn (l list int, f fn (int) string ) list string => {
    list.map(f)
}
    
module enum = {
    let map = (l list 'a, f fn ('a) => 'b) list 'b => {

    }
    let reduce = (l list 'a, f ('a) => 'b) 'b => {

    }
}

l = [4, 5, 6, 7, 8]
use enum.{take, filter, reduce}

num = l

num
|> filter(fn (a) => a % 2 == 0)
|> take(2)
|> reduce(fn (a, b) => a + b)

# num = 10

filtered_list = enum.filter(list, fn (a) => a % 2 == 0)
# filtered_list = [4, 6, 8]

a = 4

if a < 6 {

}
else {

}


type state = { total_count int, reset_count int}

type message = :add int | :reset | :get_count

let counter = actor state {
    init = fn ({start}) state => {total_count = start, reset_count = 0}
    reducer = fn (s state, m message, sender (option actor)) state => {
        match m {
            :add num => {s | total_count = s.total_count + num},
            :reset => {s | total_count = 0, reset_count = s.reset_count + 1},
            :get_count => {
                actor.reply (sender, s.total_count)
                s
            }
        }
    }
}

type counter_args = {start int}

let pid = go (counter.init ({start = 5}))

tell (pid, :add 7)

tell (pid, :reset)

let (:ok count) = ask (counter, get_count)

num = match count {
    :ok num => num,
    :error m => m
}

module stack = {
    use actor.{go, tell, ask, reply}
    type pid 't = actor.pid (stack_actor 't)
    let init = fn 't ({buffer_size}) pid 't => {
        go (stack_actor.init 't ({buffer_size}))
    }

    let push = fn (s pid 't, e 't) => {
        tell (s, :push e)
    }
    let pop = fn (s pid 't) => {
        tell (s, :pop)
    }

    let get_top = fn (s pid 't) 't => {
        ask (s, :get_top)
    } 

    type stack_state 't = {
        data list 't = [],
        buffer_size int = 5
    }

    type _message = :push 't | :pop | :get_top

    let stack_actor 't = actor stack_state 't {
        init = fn 't ({buffer_size}) stack_state 't => {
            {data = [], buffer_size}
        }
        reducer = fn(s stack_state 't, m message, sender option actor.pid) stack_state 't => {
            match m {
                :push e => {s | data=[e | data]},
                :pop => {
                    {s | data=data[1..]}
                },
                :get_top => {
                    reply (sender, s.data[0])
                }
            }
        }
    }
    
}


let s = stack.init (0, {buffer_size = 5})

stack.push (s, 4)
stack.push (s, 3)
stack.pop (s)

let top = stack.get_top (s)
