
Basic Types:
int
list
float
string
tag
record
map
function
bool
variant
atom


let g = [3, 4, 5]

let a = 4

a = 4

let b = "hello"

let add_them = fn (a Int, b Int) Int => {
    a + b
}

let also_adds = fn (a int, b int) => a + b

let add_generic = fn (a 't, b 't) 't => a + b

let c = add_generic (3, 4)

let list_creator = fn (typ 't) => {
    let h = heap.init(typ, [])
}

let ignore_second = fn (b int, _) => b + 2

type Result 't = :Ok 't | :Error String

let private_func = fn (b Int, {a, c} User) => {
    g = match return_value(a) {
        :Ok v => v,
        :Error "specific message" => "hello",
        :Error message => message
    }
}

private_func (5, user{a="scott", b="swarthout"})

enum.each(0..10, fn (i) => {
})

list


let mut a = 4

a = 5

let changes_val = fn (mut b) => {
    b = 3
}

changes_val(a)

# a = 4

type Map 'k 'v = {

}

let v = %{
    3 => "three",
    4 => "four",
    5 => "five"
}

w = %{v | 6 => "six", 5 => "cinco"} :: Dict Int String

let l = [0..17] :: List Int

l = [0..23]

v = l[4..8]

x = l[7..1]

d = l[2..]

e = l[..4]

type User = {a string, b string}

let u = {a="hello", b="world"}

let r = {u | b="again"}

type Heap 't = {

}

let a = with {
    b <- returns_result()
    c <- get_other_thing(b)
    d <- another_op()
} yield perform_thing(c, d)

user_id = "Scott",
    age = 21,
    car = {
        name = "Mustang",
        miles = 12345
        }
import fmt from "std/fmt"
import user, comment from "github.com/scott/blog"

import http from "std/net/http"

let post_handler = fn (r http.Request) => {
    let {id, username} = http.get_vars(r)
}

use http.{Request}
let req_handler = fn (r Request) => {
     let routes = {
        :get "/hello" => fn (r http.Request) => {
            "Yo Dawg"
        },
        :post "/hello/{id}" => fn (r http.Request) => {
            let {id} = http.get_vars(r)
            let response = {} :: Dict Int String
            json.dump(response)
        },
        :post "/hello/{id Int}/{username Option String}" => post_handler
        }
    }
}

let server = http.Server{port=3000, router=req_handler}

http.listen (server)

type Comment = {user_id Int, comment_id Int, text String}

let s = r.b

v[3]

let a = [3, 4, 5]

a = b <> "world!"

module math = {
    let sum = fn (a int, b int) => (do_sum_ (a, b))
    
    let do_sum_ = fn (a int, b int) int => (a + b)

    let is_zero = fn (a int) bool => {
        match a {
            0 => true,
            _ => false
        }
    }

    let positive = fn (x int) bool => {
        match {
            x < 0 => false,
            x >= 0 => true
        }
    }
}

let anonymous_func = fn (a, b) => a + b

module stack = {
    type t 'a = {
        data list 'a,
        buffer_size int
    }
    let init = fn (init_list list 'a, buffer_size int) stack.t 'a => {
        {data = init_list, buffer_size}
    }

    let push = fn (s stack.t 'a, e 'a) stack.t 'a => {
        {s | data=[e | data]}
    }
    let pop = fn (s stack.t 'a) stack.t 'a => {
        {s | data=data[1..]}
    }
}

s = stack.init ([] :: list int, 5)

let a = 5

s = stack.push (s, 4)

use stack.push

s = push (s, 3)

s = s |> push (6) 

a = stack.pop (s)


let reverse = fn (s stack.t 'a) stack.t 'a => {
    match {
        stack.empty?(s) => s,
        _ => {
            let top = stack.peek_top(s)
            s
            |> stack.pop()
            |> reverse()
            |> stack.push(top)
        }
    }

}

# a int = 6

let map_int_string = fn (l list string, f fn (string) string ) list string => {
    enum.map(l, f)
}
    
module enum = {
    let map = (l list 'a, f fn ('a) 'b) list 'b => {

    }
    let reduce = (l list 'a, f fn ('a, 'b) 'b) 'b => {

    }
}

l = [4, 5, 6, 7, 8]
use enum.{take, filter, reduce}

num = l

num
|> enum.filter(fn (a) => a % 2 == 0)
|> enum.take(2)
|> enum.reduce(fn (a, b) => a + b)

# num = 10

filtered_list = enum.filter(list, fn (a) => a % 2 == 0)
# filtered_list = [4, 6, 8]

a = 4

if a < 6 {

}
else {

}


type State = { total_count Int, reset_count Int}

type Message = :Add Int | :Reset | :GetCount

let counter_reducer = fn (s State, m Message, sender Option actor.Actor) State => {
        match m {
            :Add num => ({s | total_count = s.total_count + num}),
            :Reset => ({s | total_count = 0, reset_count = s.reset_count + 1}),
            :GetCount => {
                actor.reply (sender, s.total_count)
                s
            }
        }
    }
}

type CounterArgs = {start Int}

let init_counter = fn (args CounterArgs) actor.Pid => {
    let init_state = {
        total_count=start,
        reset_count=0
    }
    actor.start(init_state, counter_reducer)
}

let counter = init_counter({start=5})

actor.tell(counter, :Add 7)

tell (counter, :Reset)

let count = actor.ask (counter, :GetCount)

num = match count {
    :Ok num => num,
    :Error m => m
}

module stack = {

    type State_ 't = {
        data List 't,
        buffer_size Int
    }

    type message_ = :push 't | :pop | :get_top

    let reducer_ = fn(s state_ 't, m message_, sender option actor.pid) state_ 't => {
        match m {
            :push e => {
                {s | data=[e | data]}
             },
            :pop => {
                {s | data=data[1..]}
            },
            :get_top => {
                actor.reply (sender, s.data[0])
                s
            }
        }
    }

    let init = fn ('t, buffer_size int ) actor.pid => {
        let init_state = {
            data = list.init('t),
            buffer_size
        }
        actor.go (init_state, reducer_)
    }

    let push = fn (s actor.pid, e 't) => {
        actor.tell (s, :push e)
    }
    let pop = fn (s pid 't) => {
        actor.tell (s, :pop)
    }

    let get_top = fn (s pid 't) 't => {
        actor.ask (s, :get_top)
    } 

}



let s = stack.init (int, 5)

stack.push (s, 4)
stack.push (s, 3)
stack.pop (s)

let top = stack.get_top (s)
