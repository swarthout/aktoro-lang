
Basic Types:
int
list
array
float
string
tag
record
map
function
bool
tuple
chan

g = [|3, 4, 5|]

a int = 4

a = 4

b string = "hello"

def add_them(a int, b int) int => {
    a + b
}

def also_adds(a int, b int) => a + b

def ignore_second(b int, _) => b + 2

type result 't = Ok 't | Error (message string)

defp private_func(b int, User{a, c}) => {
    g = match return_value(a) {
        Ok v => v,
        Error "specific message" => "hello",
        Error message => message
    }
}

go private_func(5, User{a="scott", b="swarthout"})

for i in 0..10 {
    go (i) => {

    }
}


c chan string

d = Channel.new(t=string, buffer_size=5)


send c "hello"

send c "world"

n = recv c

b string = recv c

type map 'k 'v = {

}

v map int string = {
    3 => "three",
    4 => "four",
    5 => "five"
}

w = {v | 6 => "six", 5 => "cinco"}

l list int = [0..17]

l = [0..23]

v = l[4..8]

x = l[7..1]

d = l[2..]

e = l[..4]

type User = {a string, b string}

type Heap 't = {

}


import Fmt from "std/fmt"
import User, Comment from "github.com/scott/blog"

type Comment = {user_id int, comment_id int, text string}

u = User{a="hello", b="world"}

r = User{u | b="again"}

s string = r.b

v[3]

a list int = [3, 4, 5]

[head | tail] = a

a = b <> "world!"

t = {"world", 3, 4.9}

{b, n, c} = t

module Math {
    def sum(a int, b int) => do_sum(a, b)

    defp do_sum(a int, b int) int => a + b

    def zero?(a int) bool => {
        match a {
            0 => true,
            _ => false
        }
    }

    def positive(x int) => {
        match {
            x < 0 => false,
            x >= 0 => true
        }
    }
}

anonymous_func = (a, b) => a + b

other_func = b => b + 2

module Stack {
    type Stack 't = {
        data list 't,
    }
    def push(s Stack 't, e 't) Stack 't => {
        Stack{data=[e | data]}
    }
    def pop(s Stack 't) Stack 't=> {
        Stack{data=data[1..]}
    }
}

s Stack int

s = Stack.push(s, 4)

type push = Stack.push

s = push(s, 3)

s = s |> push(6) 

a = Stack.pop(s)

# a int = 6


module Calendar = {
    type Calendar = {}
    type 
}
    
module Enum = {
    def map(l list 'a, f ('a) => 'b) list 'b => {

    }
    def reduce(l list 'a, f ('a) => 'b) 'b => {

    }
}

l = [4, 5, 6, 7, 8]
type take = Enum.take

num = l

num
|> Enum.filter(a => a % 2 == 0)
|> take(2)
|> Enum.reduce((a, b) => a + b)

# num = 10

filtered_list = Enum.filter(list, a => a % 2 == 0)
# filtered_list = [4, 6, 8]

a = 4

if a < 6 {

}
else {

}