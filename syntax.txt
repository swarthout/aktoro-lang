
Basic Types:
int
list
array
float
string
tag
record
map
function
bool
tuple
chan

g = [|3, 4, 5|]

a int = 4

a = 4

b string = "hello"

add_them = (a int, b int) int => {
    a + b
}

also_adds = fn (a int, b int) => a + b

ignore_second = fn (b int, _) => b + 2

type result 't = Ok 't | Error (message string)

private_func = fn (b int, User{a, c}) => {
    g = match return_value(a) {
        ok v => v,
        error "specific message" => "hello",
        error message => message
    }
}

go private_func(5, User{a="scott", b="swarthout"})

for i in 0..10 {
    go fn (i) => {

    }
}


let mut a = 4

a = 5

let changes_val = fn (mut b) => {
    b = 3
}

changes_val(a)

# a = 4

c chan string

d = chan int {buffer_size=5}


send c "hello"

send c "world"

n = recv c

b string = recv c

type map 'k 'v = {

}

let v map int string = {
    3 => "three",
    4 => "four",
    5 => "five"
}

w = {v | 6 => "six", 5 => "cinco"}

l list int = [0..17]

l = [0..23]

v = l[4..8]

x = l[7..1]

d = l[2..]

e = l[..4]

type user = {a string, b string}

type heap 't = {

}


import fmt from "othello/fmt"
import user, comment from "github.com/scott/blog"

external import http from "net/http"

let req_handler = fn (r http.request) => {
    match r.request {
        http.get "/hello" => {
            "Yo Dawg"
        },
        http.post "/hello/{id}" id => {
            let response map int string = {
                id => "Your id is \(id)"
                id + 1 => "The next is \(id + 1)"
            }
            json.dump(response)
        }
    }
}

let server = http.server{port=3000, router=req_handler}

http.listen(server)

type comment = {user_id int, comment_id int, text string}

let u = user{a="hello", b="world"}

let r = {u | b="again"}

s string = r.b

v[3]

let a list int = [3, 4, 5]

[head | tail] = a

a = b <> "world!"

t = {"world", 3, 4.9}

{b, n, c} = t

module math = {
    let sum = fn (a int, b int) => do_sum a, b

    @private
    let do_sum = fn (a int, b int) int => a + b

    let zero? = fn (a int) bool => {
        match a {
            0 => true,
            _ => false
        }
    }

    let positive = fn (x int) => {
        match {
            x < 0 => false,
            x >= 0 => true
        }
    }
}

let anonymous_func = fn (a, b) => a + b

other_func = b => b + 2

module stack {
    type stack 't = {
        data list 't = [],
        buffer_size = 5
    }
    let push = fn (s stack 't, e 't) stack 't => {
        stack{data=[e | data]}
    }
    pop = (s stack 't) stack 't => {
        stack{data=data[1..]}
    }
}

s stack int

k = stack int {buffer_size=2}

s = stack.push(s, 4)

type push = stack.push

s = push(s, 3)

s = s |> push(6) 

a = stack.pop(s)

# a int = 6


module calendar = {
    type calendar = {}
    type 
}

let map_int_string = fn (l list int, f fn (int) string ) list string => {
    list.map(f)
}
    
module enum = {
    map = (l list 'a, f fn ('a) => 'b) list 'b => {

    }
    reduce = (l list 'a, f ('a) => 'b) 'b => {

    }
}

l = [4, 5, 6, 7, 8]
type take = enum.take

num = l

num
|> enum.filter(a => a % 2 == 0)
|> take(2)
|> enum.reduce((a, b) => a + b)

# num = 10

filtered_list = enum.filter(list, a => a % 2 == 0)
# filtered_list = [4, 6, 8]

a = 4

if a < 6 {

}
else {

}